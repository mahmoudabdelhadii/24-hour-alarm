0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 440 Hz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P3.7 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 24000000 ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 2000*2    ; The tone we want out is A mayor.  Interrupt rate must be twice as fast.
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/(TIMER0_RATE))))
0000             13   TIMER2_RATE   EQU 10000    ; 1000Hz, for a timer tick of 1ms
0000             14   TIMER2_RELOAD EQU ((65536-(CLK/(TIMER2_RATE))))
0000             15   
0000             16   BOOT_BUTTON   equ P3.7
0000             17   SOUND_OUT     equ P2.1
0000             18   date_button        equ P3.3
0000             19   UPDOWN       equ         p0.0
0000             20   HOURBUTTON    equ p2.6
0000             21   MINUTEBUTTON  equ p2.4
0000             22   SECONDBUTTON  equ p2.2
0000             23   ;ALARMBUTTON   equ p3.3
0000             24   
0000             25   ; Reset vector
0000             26   org 0x0000
0000 020232      27       ljmp main
0003             28   
0003             29   ; External interrupt 0 vector (not used in this code)
0003             30   org 0x0003
0003 32          31            reti
0004             32   
0004             33   ; Timer/Counter 0 overflow interrupt vector
000B             34   org 0x000B
000B 020125      35            ljmp Timer0_ISR
000E             36   
000E             37   ; External interrupt 1 vector (not used in this code)
0013             38   org 0x0013
0013 32          39            reti
0014             40   
0014             41   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             42   org 0x001B
001B 32          43            reti
001C             44   
001C             45   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             46   org 0x0023 
0023 32          47            reti
0024             48            
0024             49   ; Timer/Counter 2 overflow interrupt vector
002B             50   org 0x002B
002B 02014E      51            ljmp Timer2_ISR
002E             52   
002E             53   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             54   dseg at 0x30
0030             55   Count1ms:     ds 2 ; Used to determine when half second has passed
0032             56   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0033             57   hours_count: ds 1
0034             58   minutes_count: ds 1
0035             59   seconds_count: ds 1
0036             60   
0036             61   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0036             62   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             63   bseg
0000             64   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             65   second_flag: dbit 1
0002             66   minute_flag: dbit 1
0003             67   hour_flag: dbit 1
0004             68   AM_PM_flag: dbit 1
0005             69   alarm_flag: dbit 1
0006             70   
002E             71   cseg
002E             72   ; These 'equ' must match the wiring between the microcontroller and the LCD!
002E             73   LCD_RS equ P2.0
002E             74   LCD_RW equ P1.7
002E             75   LCD_E  equ P1.6
002E             76   LCD_D4 equ P1.1
002E             77   LCD_D5 equ P1.0
002E             78   LCD_D6 equ P0.7
002E             79   LCD_D7 equ P0.6
                 81   	$LIST
00DC             83   
00DC             84   ;                   1234567890123456    <- This helps determine the location of the counter
00DC 2D2D3A2D    85   Clock_message:  db '--:--:-- -M     ', 0
     2D3A2D2D
     202D4D20
     20202020
     00
00ED 414C4152    86   Alarm_meesage: db  'ALARM--:--:-- -M', 0
     4D2D2D3A
     2D2D3A2D
     2D202D4D
     00
00FE 3239204A    87   date_message: db   '29 January 2020 ', 0
     616E7561
     72792032
     30323020
     00
010F             88   ;-----------------------------------;
010F             89   ; Routine to initialize the timer 0 ;
010F             90   ;-----------------------------------;
010F             91   Timer0_Init:
010F 438E04      92            orl CKCON0, #00000100B ; Timer 0 uses the system clock
0112 E589        93            mov a, TMOD
0114 54F0        94            anl a, #0xf0 ; Clear the bits for timer 0
0116 4401        95            orl a, #0x01 ; Configure timer 0 as 16-timer
0118 F589        96            mov TMOD, a
011A 758CE8      97            mov TH0, #high(TIMER0_RELOAD)
011D 758A90      98            mov TL0, #low(TIMER0_RELOAD)
0120             99            ; Enable the timer and interrupts
0120 D2A9       100       setb ET0  ; Enable timer 0 interrupt
0122 D28C       101       setb TR0  ; Start timer 0
0124 22         102            ret
0125            103   
0125            104   ;---------------------------------;
0125            105   ; ISR for timer 0.                ;
0125            106   ;---------------------------------;
0125            107   Timer0_ISR:
0125            108            ;clr TF0  ; According to the data sheet this is done for us already.
0125            109            ; Timer 0 can not autoreload so we need to reload it in the ISR:
0125 C28C       110            clr TR0
0127 758CE8     111            mov TH0, #high(TIMER0_RELOAD)
012A 758A90     112            mov TL0, #low(TIMER0_RELOAD)
012D D28C       113            setb TR0
012F B2A1       114            cpl SOUND_OUT ; Toggle the pin connected to the speaker
0131 32         115            reti
0132            116   
0132            117   ;---------------------------------;
0132            118   ; Routine to initialize timer 2   ;
0132            119   ;---------------------------------;
0132            120   Timer2_Init:
0132 438E10     121            orl CKCON0, #0b00010000 ; Timer 2 uses the system clock
0135 75C800     122            mov TMR2CN0, #0 ; Stop timer/counter.  Autoreload mode.
0138 75CFF6     123            mov TMR2H, #high(TIMER2_RELOAD)
013B 75CEA0     124            mov TMR2L, #low(TIMER2_RELOAD)
013E            125            ; Set the reload value
013E 75CBF6     126            mov TMR2RLH, #high(TIMER2_RELOAD)
0141 75CAA0     127            mov TMR2RLL, #low(TIMER2_RELOAD)
0144            128            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0144 E4         129            clr a
0145 F530       130            mov Count1ms+0, a
0147 F531       131            mov Count1ms+1, a
0149            132            ; Enable the timer and interrupts
0149 D2AD       133       setb ET2  ; Enable timer 2 interrupt
014B D2CA       134       setb TR2  ; Enable timer 2
014D 22         135            ret
014E            136   
014E            137   ;---------------------------------;
014E            138   ; ISR for timer 2                 ;
014E            139   ;---------------------------------;
014E            140   Timer2_ISR:
014E C2CF       141            clr TF2H  ; Timer 2 doesn't clear TF2H automatically. Do it in ISR
0150            142            
0150            143            ; The two registers used in the ISR must be saved in the stack
0150 C0E0       144            push acc
0152 C0D0       145            push psw
0154            146            
0154            147            ; Increment the 16-bit one mili second counter
0154 0530       148            inc Count1ms+0    ; Increment the low 8-bits first
0156 E530       149            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0158 7002       150            jnz Inc_Done
015A 0531       151            inc Count1ms+1
015C            152   
015C            153   Inc_Done:
015C            154            ; Check if half second has passed
015C E530       155            mov a, Count1ms+0
015E B4F471     156            cjne a, #low(500), Timer2_ISR_doneinterm ; Warning: this instruction changes the carry flag!
0161 E531       157            mov a, Count1ms+1
0163 B4016C     158            cjne a, #high(500), Timer2_ISR_doneinterm
0166            159            
0166            160            ; 500 milliseconds have passed.  Set a flag so the main program knows
0166 D200       161            setb half_seconds_flag ; Let the main program know half second had passed
0168 B28C       162            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
016A D2A1       163            setb SOUND_OUT
016C            164            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
016C E4         165            clr a
016D F530       166            mov Count1ms+0, a
016F F531       167            mov Count1ms+1, a
0171            168            
0171            169   
0171            170            seconds:
0171 E535       171            mov     a,      seconds_count
0173 308049     172            jnb UPDOWN, Timer2_ISR_decrement
0176 2401       173            add     a, #0x01;
0178            174                ; reset second, increment minute
0178 D4         175       da           a
0179 F535       176       mov          seconds_count,    a
017B            177            ; Increment the BCD counter
017B            178            
017B D4         179            da a ; Decimal adjust instruction.  Check datasheet for more details!
017C F535       180            mov seconds_count, a
017E B46051     181            cjne    a,      #0x60,     Timer2_ISR_doneinterm
0181            182            
0181            183            minutes:
0181 C2CA       184            clr TR2                 ; Stop timer 2
0183 E4         185            clr a
0184 F530       186            mov Count1ms+0, a
0186 F531       187            mov Count1ms+1, a
0188 F535       188            mov seconds_count, a
018A D2CA       189            setb TR2
018C E534       190            mov     a,      minutes_count
018E 30802E     191            jnb UPDOWN, Timer2_ISR_decrement
0191 2401       192            add     a, #0x01;
0193            193                ; reset second, increment minute
0193 D4         194       da           a
0194 F534       195       mov          minutes_count,    a
0196            196            ; Increment the BCD counter
0196            197            
0196            198            ;;da a ; Decimal adjust instruction.  Check datasheet for more details!
0196 F534       199            mov minutes_count, a
0198 B46069     200            cjne    a,      #0x60,     Timer2_ISR_done
019B            201            
019B            202            hours:
019B E533       203            mov a,hours_count
019D B41209     204            cjne a,#0x12,AM_PM
01A0 E4         205            clr a
01A1 F534       206            mov minutes_count,a
01A3 7401       207            mov a,#0x1
01A5 F533       208            mov hours_count,a
01A7 805B       209            sjmp Timer2_ISR_done
01A9            210            
01A9            211            AM_PM:
01A9 E533       212            mov a,hours_count
01AB B41102     213            cjne a,#0x11, clear
01AE B204       214            cpl AM_PM_flag
01B0            215            clear:
01B0 E4         216            clr a
01B1 F534       217            mov minutes_count,a                                     
01B3 E533       218            mov     a,      hours_count
01B5 308007     219            jnb UPDOWN, Timer2_ISR_decrement
01B8 2401       220            add     a, #0x01;
01BA            221                ; reset second, increment minute
01BA D4         222       da           a
01BB F533       223       mov          hours_count,    a
01BD            224            ; Increment the BCD counter
01BD            225            
01BD 8013       226            sjmp  Timer2_ISR_doneinterm
01BF            227   
01BF            228   Timer2_ISR_decrement:
01BF            229   
01BF            230   
01BF E535       231            mov a, seconds_count
01C1 B40007     232            cjne a, #0x00, secjmp
01C4 7459       233            mov a, #0x59
01C6 D4         234            da a ; Decimal adjust instruction.  Check datasheet for more details!
01C7 F535       235            mov seconds_count, a
01C9 800A       236            sjmp minutedec
01CB            237   
01CB E535       238            secjmp:mov a, seconds_count
01CD 2499       239            add a, #0x99
01CF D4         240            da a
01D0 F535       241            mov seconds_count, a
01D2            242            
01D2            243            
01D2            244    
01D2 020204     245    Timer2_ISR_doneinterm: ljmp Timer2_ISR_done
01D5            246    
01D5            247    
01D5            248    minutedec:
01D5 E534       249            mov a, minutes_count
01D7 B40007     250            cjne a,#0x00, minjmp
01DA            251            
01DA 7459       252            mov a, #0x59
01DC            253            ;add a,#0x99
01DC D4         254            da a
01DD F534       255            mov minutes_count, a
01DF 8009       256            sjmp dechour
01E1            257            
01E1 E534       258   minjmp:  mov a, minutes_count
01E3 2499       259            add a, #0x99
01E5 D4         260            da a
01E6 F534       261            mov minutes_count, a
01E8            262            
01E8 801A       263            sjmp Timer2_ISR_done
01EA            264            
01EA            265            
01EA            266   dechour:
01EA            267   ;        mov a, seconds_count
01EA            268   ;        cjne a, #0x00, Timer2_ISR_done
01EA            269            
01EA            270   ;        mov a, minutes_count
01EA            271   ;        cjne a, #0x00 ,Timer2_ISR_done
01EA            272            
01EA            273   
01EA E533       274            mov a, hours_count
01EC B40109     275            cjne a, #0x01, hourjmp
01EF 7412       276            mov a,#0x12
01F1 D4         277            da a
01F2 F533       278            mov hours_count, a
01F4 E533       279            mov a, hours_count
01F6            280            
01F6 800C       281            sjmp Timer2_ISR_done
01F8            282            
01F8            283            
01F8            284   hourjmp:         
01F8 E533       285            mov a, hours_count
01FA            286            
01FA            287            
01FA 2499       288            add a,#0x99
01FC D4         289            da a
01FD B41102     290            cjne a, #0x11, skipflag
0200 B204       291            cpl AM_PM_flag
0202            292            skipflag:
0202 F533       293            mov hours_count, a
0204            294   
0204            295            
0204            296            
0204            297   ;        add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0204            298            
0204            299   Timer2_ISR_done:
0204 D0D0       300            pop psw
0206 D0E0       301            pop acc
0208 32         302            reti
0209            303   
0209            304   ;---------------------------------;
0209            305   ; Hardware initialization         ;
0209            306   ;---------------------------------;
0209            307   Initialize_All:
0209            308       ; DISABLE WDT: provide Watchdog disable keys
0209 7597DE     309            mov     WDTCN,#0xDE ; First key
020C 7597AD     310            mov     WDTCN,#0xAD ; Second key
020F            311   
020F            312       ; Enable crossbar and weak pull-ups
020F 75E100     313            mov     XBR0,#0x00
0212 75E200     314            mov     XBR1,#0x00
0215 75E340     315            mov     XBR2,#0x40
0218            316   
0218 75A602     317            mov     P2MDOUT,#0x02 ; make sound output pin (P2.1) push-pull
021B            318            
021B            319            ; Switch clock to 24 MHz
021B 75A900     320            mov     CLKSEL, #0x00 ; 
021E 75A900     321            mov     CLKSEL, #0x00 ; Second write to CLKSEL is required according to the user manual (page 77)
0221            322            
0221            323            ; Wait for 24 MHz clock to stabilze by checking bit DIVRDY in CLKSEL
0221            324   waitclockstable:
0221 E5A9       325            mov a, CLKSEL
0223 30E7FB     326            jnb acc.7, waitclockstable 
0226            327   
0226            328            ; Initialize the two timers used in this program
0226 12010F     329       lcall Timer0_Init
0229 120132     330       lcall Timer2_Init
022C            331   
022C 120088     332       lcall LCD_4BIT ; Initialize LCD
022F            333       
022F D2AF       334       setb EA   ; Enable Global interrupts
0231            335   
0231 22         336            ret
0232            337   
0232            338   ;---------------------------------;
0232            339   ; Main program.                   ;
0232            340   ;---------------------------------;
0232            341   main:
0232            342            ; Setup the stack start to the begining of memory only accesible with pointers
0232 75817F     343       mov SP, #7FH
0235            344       
0235 120209     345            lcall Initialize_All
0238            346            
0238            347       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0238 C0E0       348            push acc
023A 7401       348            mov a, #1
023C 14         348            dec a
023D 1200C1     348            lcall ?Set_Cursor_1 ; Select column and row
0240 D0E0       348            pop acc
0242 C083       349            push dph
0244 C082       349            push dpl
0246 C0E0       349            push acc
0248 9000DC     349            mov dptr, #Clock_message
024B 1200B4     349            lcall ?Send_Constant_String
024E D0E0       349            pop acc
0250 D082       349            pop dpl
0252 D083       349            pop dph
0254 C0E0       350            push acc
0256 7401       350            mov a, #1
0258 14         350            dec a
0259 1200BF     350            lcall ?Set_Cursor_2 ; Select column and row
025C D0E0       350            pop acc
025E C083       351            push dph
0260 C082       351            push dpl
0262 C0E0       351            push acc
0264 9000ED     351            mov dptr, #Alarm_meesage
0267 1200B4     351            lcall ?Send_Constant_String
026A D0E0       351            pop acc
026C D082       351            pop dpl
026E D083       351            pop dph
0270 D200       352       setb half_seconds_flag
0272 C204       353            clr AM_PM_flag
0274 753502     354            mov seconds_count, #0x02
0277 753400     355            mov minutes_count, #0x00
027A 753312     356            mov hours_count, #0x12
027D            357            
027D            358            
027D            359            
027D            360            ; After initialization the program stays in this 'forever' loop
027D            361   loop:
027D 20B71C     362            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
0280 C002       363            push AR2
0282 7A32       363            mov R2, #50
0284 120039     363            lcall ?Wait_Milli_Seconds
0287 D002       363            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0289 20B710     364            jb BOOT_BUTTON, loop_a  ; if the 'BOOT' button is not pressed skip
028C 30B7FD     365            jnb BOOT_BUTTON, $              ; Wait for button release.  The '$' means: jump to same instruction.
028F            366            ; A valid press of the 'BOOT' button has been detected, reset the BCD counter.
028F            367            ; But first stop timer 2 and reset the milli-seconds counter, to resync everything.
028F C2CA       368            clr TR2                 ; Stop timer 2
0291 E4         369            clr a
0292 F530       370            mov Count1ms+0, a
0294 F531       371            mov Count1ms+1, a
0296            372            ; Now clear the BCD counter
0296 F535       373            mov seconds_count, a
0298 D2CA       374            setb TR2                ; Start timer 2
029A 8003       375            sjmp loop_b             ; Display the new value
029C            376            
029C            377            
029C            378   loop_a:
029C 3000DE     379            jnb half_seconds_flag, loop
029F            380   loop_b:
029F C200       381       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
02A1 C0E0       382            push acc
02A3 7407       382            mov a, #7
02A5 14         382            dec a
02A6 1200C1     382            lcall ?Set_Cursor_1 ; Select column and row
02A9 D0E0       382            pop acc     ; the place in the LCD where we want the BCD counter value
02AB C000       383            push ar0
02AD A835       383            mov r0, seconds_count
02AF 1200C6     383            lcall ?Display_BCD
02B2 D000       383            pop ar0 ; This macro is also in 'LCD_4bit.inc'
02B4 C0E0       384            push acc
02B6 7404       384            mov a, #4
02B8 14         384            dec a
02B9 1200C1     384            lcall ?Set_Cursor_1 ; Select column and row
02BC D0E0       384            pop acc
02BE C000       385            push ar0
02C0 A834       385            mov r0, minutes_count
02C2 1200C6     385            lcall ?Display_BCD
02C5 D000       385            pop ar0
02C7 C0E0       386            push acc
02C9 7401       386            mov a, #1
02CB 14         386            dec a
02CC 1200C1     386            lcall ?Set_Cursor_1 ; Select column and row
02CF D0E0       386            pop acc
02D1 C000       387            push ar0
02D3 A833       387            mov r0, hours_count
02D5 1200C6     387            lcall ?Display_BCD
02D8 D000       387            pop ar0
02DA 300415     388            jnb AM_PM_flag, display_AM
02DD C0E0       389            push acc
02DF 740A       389            mov a, #10
02E1 14         389            dec a
02E2 1200C1     389            lcall ?Set_Cursor_1 ; Select column and row
02E5 D0E0       389            pop acc
02E7 C0E0       390            push acc
02E9 7441       390            mov a, #'A'
02EB 12007E     390            lcall ?WriteData
02EE D0E0       390            pop acc
02F0 8013       391                    sjmp ampmdone
02F2            392            display_AM: 
02F2 C0E0       393            push acc
02F4 740A       393            mov a, #10
02F6 14         393            dec a
02F7 1200C1     393            lcall ?Set_Cursor_1 ; Select column and row
02FA D0E0       393            pop acc
02FC C0E0       394            push acc
02FE 7450       394            mov a, #'P'
0300 12007E     394            lcall ?WriteData
0303 D0E0       394            pop acc
0305            395             ampmdone:
0305 02027D     396       ljmp loop
0308            397   END
